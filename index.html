<html>
<head>
  <title>webflower</title>
  <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
  <script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
    varying vec4 vColor;
    varying vec3 vUVz;

    void main(void) {
        float r=min(1.0,dot(vUVz.xy,vUVz.xy));
        r=1.0-r*r;
        gl_FragColor = vec4(vColor.xyz,vColor.w*r*vUVz.z);
    }
  </script>
  <script id="shader-vs" type="x-shader/x-vertex">
    attribute vec4 vaPosition;
    attribute vec3 vaColor;
    attribute vec2 vaUV;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform vec4 uScr;

    varying vec4 vColor;
    varying vec3 vUVz;

    void main(void) {
        vec4 position= uMVMatrix * vec4(vaPosition.xyz,1.0);
        position = uPMatrix * position;
        float boke=min(1.0,pow(1.0-(position.z/uScr.y),uScr.z));
        position.x = position.x+vaUV.x*vaPosition.w*(1.0+boke*uScr.w)*uScr.x;
        position.y = position.y+vaUV.y*vaPosition.w*(1.0+boke*uScr.w);
        gl_Position=position;
        vColor=vec4(vaColor,1.0-pow(boke,2.0));
        vUVz=vec3(vaUV,max(0.2,1.0-boke));
    }
  </script>
  <script type="text/javascript">

    function rotationY(v,r) {
      var cr = Math.cos(r);
      var sr = Math.sin(r);
      return [
        cr * v[0] - sr * v[2],
        v[1],
        sr * v[0] + cr * v[2]
      ];
    }
    function scale(v, s) {
      return [v[0] * s, v[1] * s, v[2] * s];
    }

    var gl;
    function initGL(canvas) {
      try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (e) {
      }
      if (!gl) {
        alert("Could not initialise WebGL, sorry :-(");
      }
    }

    function getText(id) {
      var shaderScript = document.getElementById(id);
      if (!shaderScript) {
        return null;
      }

      var str = "";
      var k = shaderScript.firstChild;
      while (k) {
        if (k.nodeType == 3) {
          str += k.textContent;
        }
        k = k.nextSibling;
      }
      return str;
    }

    function getShader(gl, id) {
      var shaderScript = document.getElementById(id);
      if (!shaderScript) {
        return null;
      }

      var str = "";
      var k = shaderScript.firstChild;
      while (k) {
        if (k.nodeType == 3) {
          str += k.textContent;
        }
        k = k.nextSibling;
      }

      var shader;
      if (shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
        return null;
      }

      gl.shaderSource(shader, str);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
      }

      return shader;
    }

    /**
     * f float
     * p Array
     */
    function BSpline(f, p) {
      var N = p.length;
      f *= N;
      if (f < 0)
        f = 0;
      if (f > N)
        f = N - 0.00001;
      var o = Math.floor(f); //offset
      var u = f - o; //interp

      var point = Array(4);
      for (var i = 0; i < 4; i++) {
        if (i + o - 1 < 0)
          point[i] = p[0];
        else if (i + o - 1 > N - 1)
          point[i] = p[N - 1];
        else
          point[i] = p[i + o - 1];
      }
      var key = [
	        (point[0] + 4 * point[1] + point[2]) / 6,
	        (point[2] - point[0]) / 2,
	        (point[0] - 2 * point[1] + point[2]) / 2,
	        (3 * (point[1] - point[2]) + point[3] - point[0]) / 6
        ];
      return (key[0] + u * (key[1] + u * (key[2] + key[3] * u)));
    }

    function vectorBSpline(f, pp) {
      return pp.map(function (a) { return BSpline(f, a); });
    }

    /**
    * @param hsv 0~1
    */
    function HSVtoRGB(h, s, v) {
      if (0 == s) {
        return [v, v, v];
      }
      if (1 < s) s = 1;
      if (h < 0) h++;
      if (1 < h) h--;
      var i = Math.floor(h * 6);
      var f = h * 6 - i;
      var p = v * (1 - s);
      var q = v * (1 - f * s);
      var t = v * (1 - (1 - f) * s);
      switch (i) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        default:
          return [v, p, q];
      }
    }

    var shaderProgram;

    function initShaders() {
      var fragmentShader = getShader(gl, "shader-fs");
      var vertexShader = getShader(gl, "shader-vs");

      shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);

      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert("Could not initialise shaders");
      }

      gl.useProgram(shaderProgram);

      shaderProgram.vertexAttribute = [];

      getText("shader-vs").split('\n').forEach(function (a) {
        var l = a.match(/va[A-Za-z]*;/);
        var c = a.match(/vec[1-4]/);
        a.match('attribute') && Array.isArray(l) && l.forEach(function (b) {
          var name = b.slice(0, b.length - 1);
          var attr = {
            name: name,
            len: Number(c[0][3]),
            location: gl.getAttribLocation(shaderProgram, name)
          };
          shaderProgram.vertexAttribute.push(attr);
          gl.enableVertexAttribArray(attr.location);
        });
      });

      shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
      shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
      shaderProgram.uScr = gl.getUniformLocation(shaderProgram, "uScr");
    }

    var count=0;

    var squareVertexPositionBuffer;
    var cubeVertexIndexBuffer;
    var numTriangles=0;

    function initBuffers() {

      var c1 = [
        [0, 3, 10, 30, 42, 45, 40],
        [0, 0, 5, 10, 15, 12, 10],
        [0, 0, 12, 20, 15, 5, 0],
        [-0.05, 0.05, 0.05, 0.0],
        [0.6, 0.6, 0.5, 0.3],
        [1.0, 1.0, 0.2],
      ];

      var pcl = [];
      var mat = mat4.create();
      for (var r = 0; r < 100; r++) {
        mat4.identity(mat);
        var s = 0.3 + (r / 100);
        mat4.scale(mat, [s, 1 / Math.pow(0.3 + r / 100, 1.1), s]);
        mat4.rotateY(mat, Math.PI / 2.34 * r);
        mat4.translate(mat, [r * 0.25, r * 0.1, 0]);

        var len = Math.floor(40 + r * 0.1);
        for (var i = 5; i < len - 5; i++) {
          var p = vectorBSpline(i / len, c1);
          var q = [];
          mat4.multiplyVec3(mat, [p[0], p[1], p[2] ], q);
          var col = HSVtoRGB(p[3] + r / 200-0.1, p[4] + r / 600, p[5]);
          pcl.push({ pos: [q[0], q[1], q[2] ], col: col });
          mat4.multiplyVec3(mat, [p[0], p[1], -p[2]], q);
          pcl.push({ pos: [q[0], q[1], q[2]], col: col });
        }
      }
      document.getElementById('show_poly').innerHTML = pcl.length + ":particles " + pcl.length * 4 + ":vertices " + pcl.length * 4 * 9 * 4 + ":bytes";


      var UV = [[1, 1], [-1, 1], [1, -1], [-1, -1]];
      var vtx = Array(pcl.length * 4 * 9);
      var N = 0;
      for (var i = 0; i < pcl.length; i++) {
        var size = 0.7;
        for (var j = 0; j < 4; j++) {
          var p = pcl[i].pos;
          vtx[N++]=p[0];
          vtx[N++]=p[1];
          vtx[N++]=p[2];
          vtx[N++]=size;
          vtx[N++]=pcl[i].col[0];
          vtx[N++]=pcl[i].col[1];
          vtx[N++]=pcl[i].col[2];
          vtx[N++]=UV[j][0];
          vtx[N++]=UV[j][1];
        }
      }
      var vertices = vtx.length / 9;
      numTriangles = vertices / 4 * 2 ;

      squareVertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtx), gl.STATIC_DRAW);
      squareVertexPositionBuffer.numItems = vertices;

      var idx = [];
      for (var i = 0; i < vertices / 4; i++) {
        idx = idx.concat([i * 4 + 0, i * 4 + 1, i * 4 + 2, i * 4 + 2, i * 4 + 1, i * 4 + 3]);
      }
      cubeVertexIndexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(idx), gl.STATIC_DRAW);
    }

    function drawScene() {
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      var mvMatrix = mat4.create();
      var pMatrix = mat4.create();
      mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 1, 200.0, pMatrix);

      gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
      var offs = 0, stride = 0;
      shaderProgram.vertexAttribute.forEach(function (a) { stride += a.len * 4; });
      shaderProgram.vertexAttribute.forEach(function (a) {
        gl.vertexAttribPointer(a.location, a.len, gl.FLOAT, false, stride, offs);
        offs += a.len * 4;
      });
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
      var view = mat4.create();

      var from = [
        [0,0, 30, 60, -40, -20, 0 ],
        [30,30, 20, 20, 20, 40, 30 ],
        [70,70, 60, 0, -60, 0, 70 ]
      ];
      var to = [
        [0, 0, 10, -10, 0],
        [10, 10, 20, 20, 10],
        [0, 0, 0, 0, 0]
      ];
      var focus =
        [70, 70, 70, 20, 20, 70, 70];
      var D =
        [1.5, 1.5, 4.0, 1.5, 1.5];

      var f = (count % 600) / 600;
      mat4.lookAt(vectorBSpline(f, from), vectorBSpline(f, to), [0, 1, 0], view);

      gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
      gl.uniform4f(shaderProgram.uScr, 9 / 16, BSpline(f, focus), 1.5, BSpline(f, D));

      mat4.identity(mvMatrix);
      mat4.multiply(view, mvMatrix, mvMatrix);
      mat4.rotateY(mvMatrix, count / 500);
      mat4.scale(mvMatrix, [0.4, 0.4, 0.4]);

      gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
      gl.drawElements(gl.TRIANGLES, numTriangles * 3, gl.UNSIGNED_SHORT, 0);
      count++;
      setTimeout(drawScene, 16);
    }

    var last_count = 0;
    function FPS() {
      document.getElementById('show_FPS').innerHTML = "FPS: " + (count - last_count);
      last_count = count;
    }

    function webGLStart() {
      var canvas = document.getElementById("main_frame");
      initGL(canvas);
      initShaders();
      initBuffers();

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.disable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

      setTimeout(drawScene, 16);
      setInterval(FPS, 1000);
    }


  </script>
</head>
<body onload="webGLStart();">
  <canvas id="main_frame" style="border: none;" width="1024" height="576"></canvas>
  <br />
  <table>
    <tr>
      <td id="show_FPS">
      </td>
      <td id="show_poly">
      </td>
    </tr>
  </table>
</body>
</html>
