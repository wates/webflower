<html>
<head>
  <title>webflower</title>
  <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
  <script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
    varying vec2 vUV;

    void main(void) {
        float r=dot(vUV,vUV);
        r=r*r;
        gl_FragColor = vec4(1.0-r, 1.0-r, 1.0-r, 1.0);
    }
  </script>
  <script id="shader-vs" type="x-shader/x-vertex">
    attribute vec4 aPosition;
    attribute vec2 aUV;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform vec4 uScr;

    varying vec2 vUV;

    void main(void) {
        vec4 position= uMVMatrix * vec4(aPosition.xyz,1.0);
        position = uPMatrix * position;
        position.x = position.x+aUV.x*aPosition.w*uScr.x;
        position.y = position.y+aUV.y*aPosition.w;
        gl_Position=position;
        vUV=aUV;
    }
  </script>
  <script type="text/javascript">

    function rotationY(v,r) {
      var cr = Math.cos(r);
      var sr = Math.sin(r);
      return [
        cr * v[0] - sr * v[2],
        v[1],
        sr * v[0] + cr * v[2]
      ];
    }

    var gl;
    function initGL(canvas) {
      try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (e) {
      }
      if (!gl) {
        alert("Could not initialise WebGL, sorry :-(");
      }
    }


    function getShader(gl, id) {
      var shaderScript = document.getElementById(id);
      if (!shaderScript) {
        return null;
      }

      var str = "";
      var k = shaderScript.firstChild;
      while (k) {
        if (k.nodeType == 3) {
          str += k.textContent;
        }
        k = k.nextSibling;
      }

      var shader;
      if (shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
        return null;
      }

      gl.shaderSource(shader, str);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
      }

      return shader;
    }

    /**
     * f float
     * p Array
     */
    function BSpline(f,p) {
      var N = p.length;
      f *= N;
      if (f < 0)
        f = 0;
      if (f > N)
        f = N - 0.00001;
      var o = Math.floor(f); //offset
      var u = f - o; //interp

      var point = Array(4);
      for (var i = 0; i < 4; i++) {
        if (i + o - 1 < 0)
          point[i] = p[0];
        else if (i + o - 1 > N - 1)
          point[i] = p[N - 1];
        else
          point[i] = p[i + o - 1];
      }
      var key = [
	        (point[0] + 4 * point[1] + point[2]) / 6,
	        (point[2] - point[0]) / 2,
	        (point[0] - 2 * point[1] + point[2]) / 2,
	        (3 * (point[1] - point[2]) + point[3] - point[0]) / 6
        ];
      return (key[0] + u * (key[1] + u * (key[2] + key[3] * u)));
    }

    function vectorBSpline(f, pp) {
      return pp.map(function (a) { return BSpline(f, a); });
    }

    /**
    * @param hsv 0~1
    */
    function HSVtoRGB(h, s, v) {
      if (0 == s) {
        return [v, v, v];
      }
      var i = Math.floor(h * 6);
      var f = h * 6 - i;
      var p = v * (1 - s);
      var q = v * (1 - f * s);
      var t = v * (1 - (1 - f) * s);
      switch (i) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        default:
          return [v, p, q];
      }
    }

    var shaderProgram;

    function initShaders() {
      var fragmentShader = getShader(gl, "shader-fs");
      var vertexShader = getShader(gl, "shader-vs");

      shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);

      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert("Could not initialise shaders");
      }

      gl.useProgram(shaderProgram);

      shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aPosition");
      gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
      shaderProgram.vertexUVAttribute = gl.getAttribLocation(shaderProgram, "aUV");
      gl.enableVertexAttribArray(shaderProgram.vertexUVAttribute);

      shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
      shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
      shaderProgram.uScr = gl.getUniformLocation(shaderProgram, "uScr");
    }

    var count=0;
    var mvMatrix = mat4.create();
    var pMatrix = mat4.create();

    function setMatrixUniforms() {
      gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
      gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
      gl.uniform4f(shaderProgram.uScr, 9/16,0,0,0);
    }

    var squareVertexPositionBuffer;
    var cubeVertexIndexBuffer;
    var numTriangles=0;

    function initBuffers() {

      var c1 = [
        [2, 2, 10, 30, 42, 45, 40],
        [0, 0, 5, 10, 15, 12, 10],
        [0, 0, 12, 20, 15, 5, 0],
      ];

      var pcl = [];
      var len = 50;
      for (var i = 3; i < len-4; i++) {
        var p = vectorBSpline(i / len, c1);
        pcl.push({ pos: p });
        var q = vectorBSpline(i / len, c1);
        q[2] *= -1;
        pcl.push({ pos: q });
      }


      var UV = [[1, 1], [-1, 1], [1, -1], [-1, -1]];
      var vtx = [];
      for (var r = 0; r < 5; r++) {
        for (var i = 0; i < pcl.length; i++) {
          var size = 0.7;
          for (var j = 0; j < 4; j++) {
            var p = rotationY(pcl[i].pos, r * Math.PI * 2 / 5);
            vtx = vtx.concat(
            [p[0], p[1], p[2], size, UV[j][0], UV[j][1]]

          );
          }
        }
      }
      var vertices = vtx.length / 6;
      numTriangles = vertices / 4 * 2 ;

      squareVertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtx), gl.STATIC_DRAW);
      squareVertexPositionBuffer.numItems = vertices;

      var idx = [];
      for (var i = 0; i < vertices / 4; i++) {
        idx = idx.concat([i * 4 + 0, i * 4 + 1, i * 4 + 2, i * 4 + 2, i * 4 + 1, i * 4 + 3]);
      }
      cubeVertexIndexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(idx), gl.STATIC_DRAW);
    }

    var pos = [
    ];

    function drawScene() {
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 1, 1000.0, pMatrix);

      mat4.identity(mvMatrix);

      mat4.rotateX(mvMatrix,Math.PI/8);
      mat4.translate(mvMatrix, [20, -40.0, -70.0]);
      mat4.rotateY(mvMatrix, count / 100);
      mat4.scale(mvMatrix,[0.3,0.3,0.3]);


//      mat4.translate(mvMatrix, [3.0, 0.0, 0.0]);
      gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 4, gl.FLOAT, false, 24, 0);
      gl.vertexAttribPointer(shaderProgram.vertexUVAttribute, 2, gl.FLOAT, false, 24, 16);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
      setMatrixUniforms();
      gl.drawElements(gl.TRIANGLES, numTriangles * 3, gl.UNSIGNED_SHORT, 0);

      count++;
    }

    function webGLStart() {
      var canvas = document.getElementById("main_frame");
      initGL(canvas);
      initShaders();
      initBuffers();

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.disable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

      setInterval(drawScene, 15);
    }


  </script>
</head>
<body onload="webGLStart();">
  <canvas id="main_frame" style="border: none;" width="1024" height="576"></canvas>
</body>
</html>
